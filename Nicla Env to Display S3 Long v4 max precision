/*
 * Nicla Sense Env → T‑Display S3 Long (ESP32‑S3 + AXS15231B, 180×640)
 * Precision‑Max build:
 *   - Upgraded formatting (°C to 0.001, %RH to 0.01, gases/adaptive decimals)
 *   - 10‑sample rolling std‑dev per metric + adaptive decimal places
 *   - EMA smoothing for display (alert logic unchanged)
 *   - VOC Alert + LED mirroring + thresholds card
 *   - Mode selection (Indoor/Outdoor), long‑press Cleaning
 *   - IAQ stabilization banner (~15 min)
 *
 * Refs:
 *  - Nicla Sense Env library (I2C, modes, cleaning, LEDs, metrics):
 *      https://github.com/arduino-libraries/Arduino_NiclaSenseEnv
 *  - ZMOD4410 IAQ baseline stabilization guidance (~15 min typical):
 *      https://community.renesas.com/analog-products/sensors/f/support/34951/zmod4410-reduce-warm-up
 *
 * If your installed library uses different method names (e.g., setIndoorAirQualityMode),
 * open its Examples and adjust the calls marked "adjust if needed".
 */

// -------------------- Includes --------------------
#include "AXS15231B.h"             // LilyGO AXS driver (from T-Display-S3-Long repo /lib)
#include <Arduino.h>
#include <Wire.h>
#include <TFT_eSPI.h>
#include <Arduino_NiclaSenseEnv.h> // Official Arduino library for Nicla Sense Env

// -------------------- I2C Pins --------------------
// A) Common on many T‑Display S3 Long setups:
#define I2C_SDA_PIN 15
#define I2C_SCL_PIN 10
// B) If you use on‑board Qwiic header (some revisions):
// #define I2C_SDA_PIN 43
// #define I2C_SCL_PIN 44

// -------------------- Buttons ---------------------
// KEY on many S3 Long variants (change if your board differs)
#define PIN_KEY  14
#define KEY_ACTIVE_LOW  1

// -------------------- Display / Objects -----------
TFT_eSPI tft(180, 640);
TFT_eSprite sprite(&tft);
NiclaSenseEnv nicla(Wire);

// -------------------- Theme -----------------------
#define COL_BG     0x0000
#define COL_PANEL  0x0842
#define COL_FRAME  0x3186
#define COL_TEXT   0xFFFF
#define COL_MUTED  0xAD55
#define COL_ACCENT 0xFDA0
#define COL_CYAN   0x07FF
#define COL_WARN   0xFFE0
#define COL_GOOD   0x07E0
#define COL_BAD    0xF800
#define COL_BARBG  0x0841
#define COL_RED    0xF800

// -------------------- Modes -----------------------
enum UIMode : uint8_t { MODE_INDOOR = 0, MODE_OUTDOOR = 1 };
UIMode currentMode = MODE_INDOOR;

// IAQ warm-up (ZMOD4410 baseline stabilization)
const uint32_t IAQ_STABILIZE_MS = 15UL * 60UL * 1000UL; // ~15 minutes
uint32_t modeStartMs = 0;

// -------------------- Sampling cadence ------------
const uint32_t SAMPLE_MS = 1000;

// -------------------- VOC thresholds (CONFIG) -----
// TVOC category bands (ppb) — tunable for your environment
static const float TVOC_GOOD_MAX_PPB     = 300.0f;    // Good:    0..300
static const float TVOC_MODERATE_MAX_PPB = 1000.0f;   // Moderate: 300..1000
static const float VOC_ALERT_TVOC_PPB    = 1000.0f;   // Alert when TVOC > 1000 ppb (red banner)
static const float VOC_ALERT_ETHANOL     = 0.50f;     // Alert when Ethanol index > 0.50

// IAQ bands (index) — tune if your firmware uses different scaling
static const float IAQ_GOOD_MAX = 50.0f;              // Good:     ≤ 50
static const float IAQ_MOD_MAX  = 100.0f;             // Moderate:  51..100

// -------------------- Button handling -------------
uint32_t lastKeyChangeMs = 0;
bool lastKeyLevel = true;
bool longPressArmed = false;

// -------------------- Stats & Filters -------------
// Rolling window stats (size N=10) for adaptive precision
template<size_t N>
struct RollingWindowStats {
  float buf[N];
  size_t count = 0;
  size_t head = 0;
  double sum = 0.0, sumsq = 0.0;

  void reset(){ count=0; head=0; sum=0.0; sumsq=0.0; }
  void push(float v){
    if (isnan(v)) return; // ignore NaN samples for stats
    if (count < N){
      buf[head++] = v; if (head>=N) head=0;
      sum += v; sumsq += (double)v*v;
      count++;
    } else {
      float old = buf[head];
      buf[head] = v;
      head = (head+1)%N;
      sum += v - old;
      sumsq += (double)v*v - (double)old*old;
    }
  }
  float mean() const { return (count>0) ? (float)(sum/(double)count) : NAN; }
  float stddev() const {
    if (count==0) return NAN;
    double m = sum/(double)count;
    double var = (sumsq/(double)count) - m*m;
    if (var<0) var=0;
    return (float)sqrt(var);
  }
};

// EMA filter for display smoothing
struct EmaFilter {
  float alpha;
  bool have=false;
  float val=0;
  EmaFilter(float a=0.3f):alpha(a){}
  void reset(){ have=false; val=0; }
  void update(float x){
    if (isnan(x)) return;        // ignore NaN updates
    if (!have){ val=x; have=true; }
    else       { val = alpha*x + (1.0f-alpha)*val; }
  }
  float value() const { return have ? val : NAN; }
};

// Instantiate per metric
RollingWindowStats<10> s_tC, s_rh, s_tvoc, s_eco2, s_iaq, s_odor, s_eth, s_no2, s_o3, s_oaq;
EmaFilter f_tC(0.25f), f_rh(0.25f), f_tvoc(0.35f), f_eco2(0.35f),
          f_iaq(0.35f), f_odor(0.35f), f_eth(0.35f), f_no2(0.35f), f_o3(0.35f), f_oaq(0.35f);

// Adaptive decimals: choose decimal places by relative jitter (σ/|μ|) and cap by maxDp
int chooseDecimals(float mean, float sigma, int maxDp){
  if (isnan(mean) || isnan(sigma) || maxDp<=0) return 0;
  float absMean = fabsf(mean);
  float rsd = (absMean > 1e-9f) ? (sigma/absMean) : sigma; // small means: fall back to absolute σ
  // Heuristic bands: tighter jitter → more decimals
  if (absMean <= 1e-6f)         return min(3, maxDp);              // essentially zero & stable
  if (rsd < 0.002f)             return min(3, maxDp);              // <0.2% jitter → max
  if (rsd < 0.010f)             return min(2, maxDp);              // <1% → 2
  if (rsd < 0.050f)             return min(1, maxDp);              // <5% → 1
  return 0;
}

// Format with EMA + adaptive decimals (given stats window + maxDp)
String fmtAdaptive(const EmaFilter& ema, const RollingWindowStats<10>& stats, int maxDp){
  float v = ema.value();
  if (isnan(v)) return String("--");
  int dp = chooseDecimals(stats.mean(), stats.stddev(), maxDp);
  return String(v, dp);
}

// Big T/RH formatting (explicit maximum)
String fmtT(const EmaFilter& ema, const RollingWindowStats<10>& stats){
  float v = ema.value();
  if (isnan(v)) return String("--.--");
  // Aim for 0.001 °C when stable; drop to .01/.1 with noise
  int dp = chooseDecimals(stats.mean(), stats.stddev(), 3);
  dp = max(dp, 1); // never less than .1 °C
  return String(v, dp);
}
String fmtRH(const EmaFilter& ema, const RollingWindowStats<10>& stats){
  float v = ema.value();
  if (isnan(v)) return String("--.-");
  int dp = chooseDecimals(stats.mean(), stats.stddev(), 2);
  dp = max(dp, 1); // at least .1 %RH
  return String(v, dp);
}

// For IAQ/OAQ indices we keep 1 decimal max for meaning, but still adaptive downwards
String fmtIndex(const EmaFilter& ema, const RollingWindowStats<10>& stats){
  float v = ema.value();
  if (isnan(v)) return String("--");
  int dp = min(1, chooseDecimals(stats.mean(), stats.stddev(), 1));
  return String(v, dp);
}

// -------------------- UI helpers ------------------
void panel(int x,int y,int w,int h,uint16_t outline,uint16_t fill,int r=6){
  sprite.fillRoundRect(x,y,w,h,r,fill);
  sprite.drawRoundRect(x,y,w,h,r,outline);
}
void labelValTL(const char* label, const String& val, int x, int y, uint16_t col=COL_TEXT){
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextSize(1);
  sprite.setTextColor(COL_MUTED, COL_BG);
  sprite.drawString(label, x, y);
  sprite.setTextSize(2);
  sprite.setTextColor(col, COL_BG);
  sprite.drawString(val, x, y+14);
}
uint16_t colorAQ(float idx){
  if (isnan(idx)) return COL_MUTED;
  if (idx <= IAQ_GOOD_MAX)     return COL_GOOD;
  if (idx <= IAQ_MOD_MAX)      return COL_WARN;
  return COL_BAD;
}

// ---------------- Nicla helpers (modes/LED) -------
// Adjust names per your library examples if needed.
bool setIndoorMode(){
  return nicla.setIndoorAirQualityMode(); // adjust if needed
}
bool setOutdoorMode(){
  return nicla.setOutdoorAirQualityMode(); // adjust if needed
}
bool startCleaningPulse(){
  return nicla.startCleaning(); // adjust if needed
}
void setNiclaLedRgb(uint8_t r, uint8_t g, uint8_t b){
  nicla.setRgbLed(r,g,b);
}
void setNiclaLed565(uint16_t c){
  uint8_t r = ((c >> 11) & 0x1F) * 255 / 31;
  uint8_t g = ((c >>  5) & 0x3F) * 255 / 63;
  uint8_t b = ((c >>  0) & 0x1F) * 255 / 31;
  setNiclaLedRgb(r,g,b);
}
void setOrangeLed(bool on){
  nicla.setOrangeLed(on); // adjust or comment if not exposed by your release
}

// ---------------- UI sections ---------------------
void drawHeader(){
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextColor(COL_TEXT, COL_BG);
  sprite.setTextSize(2);
  sprite.drawString("Nicla Sense Env — T‑Display S3 Long (Precision‑Max)", 10, 6);

  // Mode badge (top-right)
  sprite.setTextDatum(TR_DATUM);
  sprite.setTextSize(1);
  sprite.setTextColor(COL_MUTED, COL_BG);
  sprite.drawString("Mode:", 630, 8);
  sprite.setTextColor(COL_ACCENT, COL_BG);
  sprite.drawString(currentMode == MODE_INDOOR ? "Indoor IAQ" : "Outdoor AQ", 630, 24);
}

void drawLeftCard(){
  panel(10, 34, 220, 140, COL_FRAME, COL_PANEL, 8);
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextSize(1);
  sprite.setTextColor(COL_MUTED, COL_PANEL);
  sprite.drawString("Sensors / Links", 20, 42);
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.drawString("HS4001: Temp / Humidity", 20, 58);
  sprite.drawString("ZMOD4410: TVOC, eCO2, IAQ", 20, 74);
  sprite.drawString("ZMOD4510: NO2, O3, OAQ",    20, 90);
  sprite.setTextColor(COL_MUTED, COL_PANEL);
  sprite.drawString("I2C (ESLOV) @ 3.3V", 20, 108);
  sprite.drawString("Arduino_NiclaSenseEnv", 20, 124);
}

void drawBigTRH(){
  panel(240, 40, 390, 70, COL_FRAME, 0x0010, 8);
  sprite.setTextDatum(MC_DATUM);
  sprite.setTextColor(COL_CYAN, 0x0010);
  sprite.setTextSize(4);
  String sT = fmtT(f_tC, s_tC);
  String sH = fmtRH(f_rh, s_rh);
  char buf[96];
  snprintf(buf, sizeof(buf), "%s °C  |  %s %%RH", sT.c_str(), sH.c_str());
  sprite.drawString(buf, 240+195, 40+35);
}

void drawIndoorSet(){
  labelValTL("Indoor IAQ",  fmtIndex(f_iaq, s_iaq), 240, 118, colorAQ(f_iaq.value()));
  labelValTL("TVOC (ppb)",  fmtAdaptive(f_tvoc,  s_tvoc, 2), 240, 150);
  labelValTL("eCO2 (ppm)",  fmtAdaptive(f_eco2,  s_eco2, 1), 420, 150);
  labelValTL("Odor idx",    fmtAdaptive(f_odor,  s_odor, 3), 240, 186);
  labelValTL("Ethanol idx", fmtAdaptive(f_eth,   s_eth,  3), 420, 186);
}

void drawOutdoorSet(){
  labelValTL("Outdoor AQ",  fmtIndex(f_oaq, s_oaq), 420, 118, colorAQ(f_oaq.value()));
  labelValTL("NO2 (ppb)",   fmtAdaptive(f_no2, s_no2, 2), 240, 222);
  labelValTL("O3  (ppb)",   fmtAdaptive(f_o3,  s_o3,  2), 420, 222);
}

void drawThresholdCard(){
  const int x=470, y=180-62, w=160, h=52;
  panel(x,y,w,h, COL_FRAME, COL_PANEL, 6);
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextSize(1);
  sprite.setTextColor(COL_MUTED, COL_PANEL);
  sprite.drawString("Thresholds", x+6, y+4);
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  char line[64];
  snprintf(line, sizeof(line), "TVOC: G<=%.0f M<=%.0f", TVOC_GOOD_MAX_PPB, TVOC_MODERATE_MAX_PPB);
  sprite.drawString(line, x+6, y+18);
  snprintf(line, sizeof(line), "IAQ:  G<=%.0f M<=%.0f", IAQ_GOOD_MAX, IAQ_MOD_MAX);
  sprite.drawString(line, x+6, y+32);
}

void drawVocAlert(bool alert, const String& reason){
  const int x=240, y=180-62, w=220, h=52;
  uint16_t fill = alert ? COL_BAD : COL_PANEL;
  panel(x,y,w,h, COL_FRAME, fill, 6);
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextSize(1);
  sprite.setTextColor(alert ? COL_TEXT : COL_MUTED, fill);
  sprite.drawString("VOC Alert", x+6, y+4);
  sprite.setTextColor(COL_TEXT, fill);
  sprite.drawString(alert ? reason : "No alerts", x+6, y+20);
  sprite.setTextColor(alert ? COL_TEXT : COL_MUTED, fill);
  sprite.drawString("TVOC/Ethanol crossed limit", x+6, y+34);
}

void drawStabilizationBanner(){
  if (currentMode != MODE_INDOOR) return;
  uint32_t elapsed = millis() - modeStartMs;
  if (elapsed >= IAQ_STABILIZE_MS) return;
  uint32_t remain = (IAQ_STABILIZE_MS - elapsed + 999)/1000;
  char msg[64];
  snprintf(msg, sizeof(msg), "Stabilizing IAQ baseline… %lus", (unsigned long)remain);

  const int x=10, y=180-22, w=220, h=16;
  panel(x,y,w,h, COL_FRAME, COL_PANEL, 6);
  sprite.setTextDatum(MC_DATUM);
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.setTextSize(1);
  sprite.drawString(msg, x+w/2, y+h/2);
}

void drawFrame(bool vocAlert, const String& vocReason){
  sprite.fillSprite(COL_BG);
  drawHeader();
  drawLeftCard();
  drawBigTRH();
  drawIndoorSet();
  drawOutdoorSet();
  drawVocAlert(vocAlert, vocReason);
  drawThresholdCard();
  drawStabilizationBanner();
  lcd_PushColors_rotated_90(0, 0, 640, 180, (uint16_t*)sprite.getPointer());
}

// --------------- Mode & LED logic ---------------
void applyMode(UIMode m){
  currentMode = m;
  modeStartMs = millis();
  bool ok = (currentMode == MODE_INDOOR) ? setIndoorMode() : setOutdoorMode();
  if (!ok) Serial.println("WARN: set mode failed (adjust API names per your library).");
}

void applyLedForState(bool vocAlert, float indoorIAQ, float outdoorAQ){
  if (vocAlert){
    setNiclaLed565(COL_BAD);     // Red for alert
    setOrangeLed(true);          // Auxiliary alert
    return;
  }
  setOrangeLed(false);
  if (currentMode == MODE_INDOOR){
    if (millis() - modeStartMs < IAQ_STABILIZE_MS){
      setNiclaLed565(COL_CYAN);
      return;
    }
    setNiclaLed565(colorAQ(indoorIAQ));
  } else {
    setNiclaLed565(colorAQ(outdoorAQ));
  }
}

// --------------- KEY handling ---------------
bool keyRead(){
  bool level = digitalRead(PIN_KEY);
  return KEY_ACTIVE_LOW ? !level : level;
}
void handleKey(){
  bool k = keyRead();
  uint32_t now = millis();

  if (k != lastKeyLevel && (now - lastKeyChangeMs) > 30){
    lastKeyChangeMs = now;
    lastKeyLevel = k;

    if (k){ longPressArmed = true; }
    else{
      if (longPressArmed && (now - lastKeyChangeMs) < 1500){
        applyMode(currentMode == MODE_INDOOR ? MODE_OUTDOOR : MODE_INDOOR);
      }
      longPressArmed = false;
    }
  }

  if (longPressArmed && (now - lastKeyChangeMs) >= 1500){
    longPressArmed = false;
    bool ok = startCleaningPulse();
    if (!ok) Serial.println("WARN: cleaning pulse failed (adjust per lib examples).");
  }
}

// --------------- Setup -----------------------
void setup() {
  Serial.begin(115200);

  // Display init
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, LOW);
  axs15231_init();
  sprite.createSprite(640, 180);
  sprite.setSwapBytes(1);
  lcd_fill(0, 0, 180, 640, 0x0000);
  digitalWrite(TFT_BL, HIGH);

  // I2C init
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  Wire.setClock(400000);

  // KEY button
  pinMode(PIN_KEY, KEY_ACTIVE_LOW ? INPUT_PULLUP : INPUT);

  // Nicla begin
  if (!nicla.begin()){
    sprite.fillSprite(COL_BG);
    sprite.setTextDatum(MC_DATUM);
    sprite.setTextColor(COL_BAD, COL_BG);
    sprite.setTextSize(2);
    sprite.drawString("Nicla Sense Env not found (I2C)", 320, 90);
    lcd_PushColors_rotated_90(0, 0, 640, 180, (uint16_t*)sprite.getPointer());
    delay(3000);
  }

  // Start in Indoor mode
  applyMode(MODE_INDOOR);
  setNiclaLed565(COL_CYAN); // active/stabilizing
}

// --------------- Loop ------------------------
void loop() {
  handleKey();

  // ---- Read a fresh sample (ALERT logic uses raw values exactly like before) ----
  float tC      = nicla.readTemperature();
  float rh      = nicla.readHumidity();

  float tvoc    = nicla.readTVOC();
  float eco2    = nicla.readECO2();
  float iaq     = nicla.readIndoorAirQuality();
  float odor    = nicla.readOdorIndex();
  float ethanol = nicla.readEthanolIndex();

  float no2     = nicla.readNO2();
  float o3      = nicla.readO3();
  float oaq     = nicla.readOutdoorAirQuality();

  // ---- Push raw into rolling stats ----
  s_tC.push(tC); s_rh.push(rh); s_tvoc.push(tvoc); s_eco2.push(eco2); s_iaq.push(iaq);
  s_odor.push(odor); s_eth.push(ethanol); s_no2.push(no2); s_o3.push(o3); s_oaq.push(oaq);

  // ---- Update EMA for smoother displayed value ----
  f_tC.update(tC); f_rh.update(rh); f_tvoc.update(tvoc); f_eco2.update(eco2); f_iaq.update(iaq);
  f_odor.update(odor); f_eth.update(ethanol); f_no2.update(no2); f_o3.update(o3); f_oaq.update(oaq);

  // ---- VOC Alert logic (unchanged thresholds) ----
  bool vocAlert = false; String vocReason;
  if (!isnan(tvoc) && tvoc > VOC_ALERT_TVOC_PPB){
    vocAlert = true; vocReason = "TVOC " + String(tvoc,1) + " ppb";
  } else if (!isnan(ethanol) && ethanol > VOC_ALERT_ETHANOL){
    vocAlert = true; vocReason = "Ethanol idx " + String(ethanol,2);
  }

  // ---- LED state per mode/alert ----
  applyLedForState(vocAlert, iaq, oaq);

  // ---- Draw frame (EMA + adaptive decimals shown) ----
  drawFrame(vocAlert, vocReason);

  delay(SAMPLE_MS);
}
