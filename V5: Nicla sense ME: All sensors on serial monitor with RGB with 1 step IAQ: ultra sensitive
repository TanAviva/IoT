/*
  Nicla Sense ME — Max-Precision Standalone
  + IAQ "warm-start" persistence, BMP390 MoM+EMA filter, and magnetometer soft-cal

  What’s new in this version
  - BSEC best-effort "state" persistence to QSPI Flash (LittleFS): last IAQ + comp T/H/G
    NOTE: Arduino_BHY2 doesn’t expose true BSEC internal state set/get; this warm-starts
    our UI/averages, not the on-sensor BSEC. (See docs / headers for BSEC frames.) 
  - BMP390: device-level OSR/IIR isn’t exposed by Arduino_BHY2; we implement MoM + EMA
    to mimic high-oversampling low-noise behavior in software.
  - Magnetometer “min–max” soft calibration at boot using RAW stream (optional),
    while still reporting the BHY2-corrected stream for convenience.

  Serial: 115200 baud
*/

// ---------- BSEC long-payload: enlarge frame to get comp_t/h/g ----------
#ifndef SENSOR_DATA_FIXED_LENGTH
#define SENSOR_DATA_FIXED_LENGTH 30
#endif

#include "Arduino.h"
#include "Arduino_BHY2.h"
#include "Nicla_System.h"
#include <math.h>

// ---------- QSPI Flash FS (LittleFS) for BSEC persistence ----------
#include "SPIFBlockDevice.h"
#include "LittleFileSystem.h"

// ======= Precision / behavior knobs =========================================
#define ODR_IMU_HZ           200   // accel/gyro/derived vectors (Hz)
#define ODR_MAG_HZ            50   // magnetometer (Hz)
#define ODR_ENV_HZ            25   // temp/hum/baro/gas (Hz)
#define PRINT_INTERVAL_MS   1000   // averaging window & print cadence (ms)

#define ACC_RANGE_CODE         2   // per Arduino_BHY2 example: code 2 => ±4 g
#define GYRO_RANGE_DPS       250   // gyro FSR (dps), use smallest safe

// BMP390 software filtering
#define BARO_MOM_GROUPS        5   // keep N 1s means and take the median
#define BARO_EMA_TAU_S         5.0 // EMA time constant (seconds) over MoM output

// IAQ LED
constexpr float LED_SAT = 1.0f;
constexpr float LED_VAL = 0.3f;     // dim to reduce thermal bias
constexpr uint8_t IAQ_HYSTERESIS_POINTS = 3;

// Magnetometer soft calibration
#define RUN_MAG_CAL_SECONDS   20    // seconds to gather raw min/max at boot
#define USE_MAG_SOFT_CAL            // comment out to skip raw soft-cal workflow

// BSEC persistence
#define BSEC_STATE_PATH  "/fs/bsec_hint.txt"
#define BSEC_SAVE_PERIOD_MS (5UL*60UL*1000UL)  // every 5 min

// ======= Sensors =============================================================
SensorXYZ         acc (SENSOR_ID_ACC);
SensorXYZ         gyro(SENSOR_ID_GYRO);
SensorXYZ         mag (SENSOR_ID_MAG);          // corrected
SensorXYZ         lacc(SENSOR_ID_LACC);
SensorXYZ         grav(SENSOR_ID_GRA);
SensorOrientation ori (SENSOR_ID_ORI);
SensorQuaternion  rv  (SENSOR_ID_RV);

#ifdef USE_MAG_SOFT_CAL
SensorXYZ         magRaw(SENSOR_ID_MAG_RAW);     // raw magnetometer for soft-cal
#endif

Sensor            temp(SENSOR_ID_TEMP);
Sensor            hum (SENSOR_ID_HUM);
Sensor            baro(SENSOR_ID_BARO);
Sensor            gas (SENSOR_ID_GAS);

// Prefer legacy BSEC (SID=171) long frame; see library notes.
SensorBSEC        bsec(SENSOR_ID_BSEC);

// Optional activity/steps
SensorActivity    activity    (SENSOR_ID_AR);
Sensor            tilt        (SENSOR_ID_TILT_DETECTOR);
Sensor            stepCounter (SENSOR_ID_STC);
Sensor            stepDetector(SENSOR_ID_STD);

// ======= Stats helpers =======================================================
struct Stats1D {
  double sum=0, sum2=0; uint32_t n=0;
  void add(double v){ sum+=v; sum2+=v*v; n++; }
  double mean() const { return n? (sum/n): NAN; }
  double stddev() const { return (n>1)? sqrt((sum2/n) - sq(sum/n)) : NAN; }
  void clear(){ sum=sum2=0; n=0; }
};
struct Stats3D { Stats1D x,y,z; void add(double a,double b,double c){x.add(a);y.add(b);z.add(c);} void clear(){x.clear();y.clear();z.clear();} };
struct QuatAcc { double sw=0,sx=0,sy=0,sz=0; uint32_t n=0;
  void add(double w,double x,double y,double z){sw+=w; sx+=x; sy+=y; sz+=z; n++;}
  bool meanUnit(double& w,double& x,double& y,double& z) const{
    if(!n) return false; double mw=sw/n, mx=sx/n, my=sy/n, mz=sz/n;
    double L=sqrt(mw*mw+mx*mx+my*my+mz*mz); if(L==0) return false;
    w=mw/L; x=mx/L; y=my/L; z=mz/L; return true;
  }
  void clear(){ sw=sx=sy=sz=0; n=0; }
};

static Stats3D accS, gyroS, magS, laccS, gravS;
#ifdef USE_MAG_SOFT_CAL
static Stats3D magRawS;              // just for per-window reporting if desired
#endif
static Stats1D tempS, humS, baroS, gasS, iaqS, eco2S, bvocS;
static QuatAcc rvQ;
static float lastPitch=NAN, lastRoll=NAN, lastHeading=NAN;
static uint32_t lastPrint=0;

// BMP390 MoM + EMA
static double baroMomBuf[BARO_MOM_GROUPS] = {NAN};
static uint8_t baroMomCount = 0, baroMomIdx = 0;
static double baroEma = NAN; // exponential moving average of MoM
static double emaAlpha = 0.0; // computed after setup

static inline double medianOf(double* a, uint8_t len){
  double b[BARO_MOM_GROUPS];
  for(uint8_t i=0;i<len;i++) b[i]=a[i];
  for(uint8_t i=1;i<len;i++){ double v=b[i]; int j=i-1; while(j>=0 && b[j]>v){ b[j+1]=b[j]; j--; } b[j+1]=v; }
  if(len==0) return NAN;
  return (len&1)? b[len/2] : 0.5*(b[len/2-1]+b[len/2]);
}

// ======= LED helpers (IAQ 1-step + hysteresis) ==============================
static inline uint16_t clampU16(int v,int lo,int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
static void hsvToRgb(float h,float s,float v,uint8_t& r,uint8_t& g,uint8_t& b){
  float c=v*s, h6=fmodf(h/60.f,6.f), x=c*(1.f-fabsf(fmodf(h6,2.f)-1.f)), m=v-c;
  float rp=0,gp=0,bp=0;
  if      (0.f<=h6 && h6<1.f){ rp=c; gp=x; bp=0; }
  else if (1.f<=h6 && h6<2.f){ rp=x; gp=c; bp=0; }
  else if (2.f<=h6 && h6<3.f){ rp=0; gp=c; bp=x; }
  else if (3.f<=h6 && h6<4.f){ rp=0; gp=x; bp=c; }
  else if (4.f<=h6 && h6<5.f){ rp=x; gp=0; bp=c; }
  else                       { rp=c; gp=0; bp=x; }
  r=(uint8_t)roundf((rp+m)*255.f); g=(uint8_t)roundf((gp+m)*255.f); b=(uint8_t)roundf((bp+m)*255.f);
}
static inline void setColorFromIdx(uint16_t idx){
  float hue = 120.f*(1.f - (idx/500.f)); uint8_t r,g,b; hsvToRgb(hue, LED_SAT, LED_VAL, r,g,b);
  nicla::leds.setColor(r,g,b);
}
static void setColorForIAQ_1step_hyst(uint16_t iaq_raw){
  static int16_t stable=-1; uint16_t idx=clampU16(iaq_raw,0,500);
  if(stable<0){ stable=(int16_t)idx; setColorFromIdx(idx); return; }
  int d=(int)idx-stable; if(d>=IAQ_HYSTERESIS_POINTS || d<=-IAQ_HYSTERESIS_POINTS){ stable=(int16_t)idx; setColorFromIdx(idx); }
}
static void updateStatusLED(){
  static uint32_t last=0; if(millis()-last<PRINT_INTERVAL_MS) return; last=millis();
  switch(bsec.accuracy()){
    case 0: nicla::leds.setColor(blue);   return;
    case 1: nicla::leds.setColor(cyan);   return;
    case 2: nicla::leds.setColor(yellow); return;
    default: break;
  }
  float iaqMean=iaqS.mean(); if(isnan(iaqMean)){ nicla::leds.setColor(cyan); return; }
  setColorForIAQ_1step_hyst((uint16_t)roundf(iaqMean));
}

// ======= QSPI Flash FS for BSEC warm-start ==================================
SPIFBlockDevice spif(SPI_PSELMOSI0, SPI_PSELMISO0, SPI_PSELSCK0, CS_FLASH);
mbed::LittleFileSystem fs("fs");

static bool fsReady=false;
static bool fsInit(){
  if(fsReady) return true;
  int err = fs.mount(&spif);
  if(err){ err = fs.reformat(&spif); }
  fsReady = (err==0);
  return fsReady;
}

static uint32_t lastBsecSave = 0;

static void saveBsecHintIfDue(){
  if(!fsInit()) return;
  if(millis() - lastBsecSave < BSEC_SAVE_PERIOD_MS) return;
  lastBsecSave = millis();

  FILE* f = fopen(BSEC_STATE_PATH, "w");
  if(!f) return;

  // Persist a minimal snapshot (best-effort UI warm-start; not true BSEC)
  // Fields: time, iaq_mean, comp_t, comp_h, comp_g
  fprintf(f, "t=%lu,iaq=%.1f,ct=%.2f,ch=%.2f,cg=%lu\n",
          (unsigned long)millis(),
          iaqS.mean(),
          bsec.comp_t(), bsec.comp_h(), (unsigned long)bsec.comp_g());
  fclose(f);
}

static bool loadBsecHint(float& iaq, float& ct, float& ch, uint32_t& cg){
  if(!fsInit()) return false;
  FILE* f = fopen(BSEC_STATE_PATH, "r");
  if(!f) return false;
  unsigned long t=0; float liaq=0, lct=0, lch=0; unsigned long lcg=0;
  int n = fscanf(f, "t=%lu,iaq=%f,ct=%f,ch=%f,cg=%lu", &t, &liaq, &lct, &lch, &lcg);
  fclose(f);
  if(n==5){ iaq=liaq; ct=lct; ch=lch; cg=(uint32_t)lcg; return true; }
  return false;
}

// ======= Magnetometer soft calibration (min–max on RAW) =====================
#ifdef USE_MAG_SOFT_CAL
static bool   magCalReady=false;
static float  magOffX=0, magOffY=0, magOffZ=0;

static void runMagCalibration(uint32_t seconds){
  Serial.println(F("[Mag Cal] Rotate the board slowly in all orientations..."));
  nicla::leds.setColor(magenta);

  float minX= 1e9, minY= 1e9, minZ= 1e9;
  float maxX=-1e9, maxY=-1e9, maxZ=-1e9;

  uint32_t endAt = millis() + seconds*1000UL;
  while((int32_t)(endAt - millis()) > 0){
    BHY2.update();
    if(magRaw.dataAvailable()){
      float x=magRaw.x(), y=magRaw.y(), z=magRaw.z();
      if(x<minX) minX=x; if(y<minY) minY=y; if(z<minZ) minZ=z;
      if(x>maxX) maxX=x; if(y>maxY) maxY=y; if(z>maxZ) maxZ=z;
      magRaw.clearDataAvailFlag();
    }
  }
  magOffX = 0.5f*(maxX+minX);
  magOffY = 0.5f*(maxY+minY);
  magOffZ = 0.5f*(maxZ+minZ);
  magCalReady = isfinite(magOffX) && isfinite(magOffY) && isfinite(magOffZ);

  Serial.print(F("[Mag Cal] Offsets X/Y/Z (uT): "));
  Serial.print(magOffX,3); Serial.print(F(", "));
  Serial.print(magOffY,3); Serial.print(F(", "));
  Serial.println(magOffZ,3);

  nicla::leds.setColor(blue);
}
#endif

// ======= Configure ===========================================================
void configureAll(){
  BHY2.begin();  // Standalone init

  // Configure streams
  acc.configure (ODR_IMU_HZ, 0);
  gyro.configure(ODR_IMU_HZ, 0);
  lacc.configure(ODR_IMU_HZ, 0);
  grav.configure(ODR_IMU_HZ, 0);
  ori.configure (ODR_IMU_HZ, 0);
  rv.configure  (ODR_IMU_HZ, 0);
  mag.configure (ODR_MAG_HZ, 0);
#ifdef USE_MAG_SOFT_CAL
  magRaw.configure(ODR_MAG_HZ, 0);
#endif

  temp.configure(ODR_ENV_HZ, 0);
  hum .configure(ODR_ENV_HZ, 0);
  baro.configure(ODR_ENV_HZ, 0);
  gas .configure(ODR_ENV_HZ, 0);

  bsec.begin();  // IAQ, comp T/H/G

  // IMU ranges (accel uses "code", e.g., 2 => ±4 g; gyro uses dps)
  acc.setRange (ACC_RANGE_CODE);
  gyro.setRange(GYRO_RANGE_DPS);

  // Optional UX
  activity.configure    (5, 0);
  tilt.configure        (5, 0);
  stepCounter.configure (1, 0);
  stepDetector.configure(5, 0);

  // Verify FSRs
  SensorConfig cfg;
  cfg = acc.getConfiguration();
  Serial.print(F("Accel FSR applied: ±")); Serial.print(cfg.range); Serial.println(F(" g"));
  cfg = gyro.getConfiguration();
  Serial.print(F("Gyro  FSR applied: ±")); Serial.print(cfg.range); Serial.println(F(" dps"));

  // EMA alpha from tau and window period
  emaAlpha = 1.0 - exp(- (double)PRINT_INTERVAL_MS / 1000.0 / BARO_EMA_TAU_S);
}

// ======= Setup / Loop ========================================================
void setup(){
  Serial.begin(115200);
  while(!Serial && millis()<3000) {}
  Serial.println(F("\nNicla Sense ME — Max-Precision Standalone + BSEC warm-start + BMP390 MoM+EMA + Mag soft-cal"));

  nicla::begin();
  nicla::leds.begin();
  nicla::leds.setColor(blue);

  configureAll();

  // Best-effort BSEC warm-start: load last IAQ & comp values for UI/averages
  float sIaq=0, sCt=0, sCh=0; uint32_t sCg=0;
  if(loadBsecHint(sIaq, sCt, sCh, sCg)){
    iaqS.add(sIaq); // seed the first window so LED doesn't start from cyan forever
    Serial.print(F("[BSEC warm-start] Loaded IAQ=")); Serial.print(sIaq,1);
    Serial.print(F(", compT/H/G=")); Serial.print(sCt,2); Serial.print(F("C, "));
    Serial.print(sCh,2); Serial.print(F("%, "));
    Serial.print(sCg); Serial.println(F(" Ohms"));
  }else{
    Serial.println(F("[BSEC warm-start] No hint file yet; will create one during run."));
  }

#ifdef USE_MAG_SOFT_CAL
  // Quick raw magnetometer soft-cal
  runMagCalibration(RUN_MAG_CAL_SECONDS);
#endif
}

void loop(){
  BHY2.update();

  // IMU / mag (corrected)
  if(acc.dataAvailable()){  accS.add(acc.x(), acc.y(), acc.z());  acc.clearDataAvailFlag(); }
  if(gyro.dataAvailable()){ gyroS.add(gyro.x(),gyro.y(),gyro.z()); gyro.clearDataAvailFlag(); }
  if(mag.dataAvailable()){   magS.add(mag.x(), mag.y(), mag.z());  mag.clearDataAvailFlag(); }

#ifdef USE_MAG_SOFT_CAL
  if(magRaw.dataAvailable()){
    float x=magRaw.x()-magOffX, y=magRaw.y()-magOffY, z=magRaw.z()-magOffZ;
    magRawS.add(x,y,z); // soft-calibrated raw accumulation (optional)
    magRaw.clearDataAvailFlag();
  }
#endif

  if(lacc.dataAvailable()){ laccS.add(lacc.x(),lacc.y(),lacc.z()); lacc.clearDataAvailFlag(); }
  if(grav.dataAvailable()){ gravS.add(grav.x(),grav.y(),grav.z()); grav.clearDataAvailFlag(); }

  if(ori.dataAvailable()){
    lastPitch=ori.pitch(); lastRoll=ori.roll(); lastHeading=ori.heading();
    ori.clearDataAvailFlag();
  }
  if(rv.dataAvailable()){ rvQ.add(rv.w(),rv.x(),rv.y(),rv.z()); rv.clearDataAvailFlag(); }

  // Environmental
  if(temp.dataAvailable()){ tempS.add(temp.value()); temp.clearDataAvailFlag(); }
  if(hum .dataAvailable()){ humS .add(hum .value()); hum .clearDataAvailFlag(); }
  if(baro.dataAvailable()){ baroS.add(baro.value()); baro.clearDataAvailFlag(); }
  if(gas .dataAvailable()){ gasS .add(gas .value()); gas .clearDataAvailFlag(); }

  // BSEC bundle
  if(bsec.dataAvailable()){
    iaqS .add(bsec.iaq());
    eco2S.add(bsec.co2_eq());
    bvocS.add(bsec.b_voc_eq());
    bsec.clearDataAvailFlag();
  }

  // Once per window
  uint32_t now = millis();
  if(now - lastPrint >= PRINT_INTERVAL_MS){
    lastPrint = now;

    // BMP390: MoM across last BARO_MOM_GROUPS window-means
    double thisBaroMean = baroS.mean();
    if(!isnan(thisBaroMean)){
      baroMomBuf[baroMomIdx] = thisBaroMean;
      baroMomIdx = (baroMomIdx + 1) % BARO_MOM_GROUPS;
      if(baroMomCount < BARO_MOM_GROUPS) baroMomCount++;
    }
    double baroMoM = medianOf(baroMomBuf, baroMomCount);
    if(!isnan(baroMoM)){
      if(isnan(baroEma)) baroEma = baroMoM;
      else               baroEma = baroEma + emaAlpha*(baroMoM - baroEma);
    }

    // Quaternion averaged
    double qw=0,qx=0,qy=0,qz=0; bool haveQ = rvQ.meanUnit(qw,qx,qy,qz);

    Serial.println();
    Serial.println(F("=================================================="));
    Serial.println(F("Averaged high-precision snapshot"));

    Serial.println(F("[Motion - means ± stddev]"));
    Serial.print(F("  Acc (m/s^2):     "));
    Serial.print(accS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(accS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(accS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(accS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(accS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(accS.z.stddev(), 6);

    Serial.print(F("  Gyro (deg/s):    "));
    Serial.print(gyroS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(gyroS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gyroS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(gyroS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gyroS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(gyroS.z.stddev(), 6);

    Serial.print(F("  Mag (uT, corrected): "));
    Serial.print(magS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(magS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(magS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(magS.z.stddev(), 6);

#ifdef USE_MAG_SOFT_CAL
    Serial.print(F("  Mag (uT, RAW soft-cal): "));
    Serial.print(magRawS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(magRawS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magRawS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(magRawS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magRawS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(magRawS.z.stddev(), 6);
#endif

    Serial.print(F("  LinAcc (m/s^2):  "));
    Serial.print(laccS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(laccS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(laccS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(laccS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(laccS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(laccS.z.stddev(), 6);

    Serial.print(F("  Gravity (m/s^2): "));
    Serial.print(gravS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(gravS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gravS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(gravS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gravS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(gravS.z.stddev(), 6);

    Serial.println(F("  Orientation (deg):"));
    Serial.print (F("    pitch="));  Serial.print(lastPitch,   6);
    Serial.print (F(", roll="));     Serial.print(lastRoll,    6);
    Serial.print (F(", heading="));  Serial.println(lastHeading, 6);

    Serial.print (F("  Rotation Vector (quat, avg): "));
    if(haveQ){
      Serial.print(F("w=")); Serial.print(qw, 6);
      Serial.print(F(", x=")); Serial.print(qx, 6);
      Serial.print(F(", y=")); Serial.print(qy, 6);
      Serial.print(F(", z=")); Serial.println(qz, 6);
    } else {
      Serial.println(F("n/a"));
    }

    Serial.println(F("[Environmental - means ± stddev]"));
    Serial.print(F("  Temperature (C): ")); Serial.print(tempS.mean(), 6); Serial.print(F(" ± ")); Serial.println(tempS.stddev(), 6);
    Serial.print(F("  Humidity (%RH):  ")); Serial.print(humS.mean(), 6);  Serial.print(F(" ± ")); Serial.println(humS.stddev(), 6);

    Serial.print(F("  Pressure (hPa):  "));
    Serial.print(baroS.mean(), 6); Serial.print(F(" (1s mean), σ=")); Serial.println(baroS.stddev(), 6);

    Serial.print(F("  Pressure MoM")); Serial.print(BARO_MOM_GROUPS);
    Serial.print(F(" (hPa): ")); if(!isnan(baroMoM)) Serial.println(baroMoM, 6); else Serial.println(F("n/a"));

    Serial.print(F("  Pressure EMA (hPa): "));
    if(!isnan(baroEma)) Serial.println(baroEma, 6); else Serial.println(F("n/a"));

    Serial.print(F("  Gas (Ohms):      ")); Serial.print(gasS.mean(), 2);  Serial.print(F(" ± ")); Serial.println(gasS.stddev(), 2);

    Serial.println(F("[Air Quality - BSEC]"));
    Serial.print (F("  IAQ: "));         Serial.print(iaqS.mean(), 2);
    Serial.print (F(" (acc "));           Serial.print(bsec.accuracy()); Serial.println(F(" of 3)"));
    Serial.print (F("  eCO2 (ppm): "));  Serial.println(eco2S.mean(), 1);
    Serial.print (F("  bVOCeq (ppm): "));Serial.println(bvocS.mean(), 3);
    Serial.print (F("  Comp T/H/G: "));
    Serial.print (bsec.comp_t(), 2); Serial.print(F(" C, "));
    Serial.print (bsec.comp_h(), 2); Serial.print(F(" %RH, "));
    Serial.print (bsec.comp_g());   Serial.println(F(" Ohms"));

    Serial.print(F("Samples this window ~ IMU: "));
    Serial.print(accS.x.n); Serial.print(F(", ENV: ")); Serial.println(tempS.n);

    // Update LED & save BSEC hint periodically
    updateStatusLED();
    saveBsecHintIfDue();

    // Clear accumulators
    accS.clear(); gyroS.clear(); magS.clear(); laccS.clear(); gravS.clear();
#ifdef USE_MAG_SOFT_CAL
    magRawS.clear();
#endif
    tempS.clear(); humS.clear(); baroS.clear(); gasS.clear();
    iaqS.clear();  eco2S.clear(); bvocS.clear(); rvQ.clear();
  }
}
