

/*
  Nicla Sense ME — High Precision Readout + RGB IAQ (1-step granularity + hysteresis)

- Standalone: reads IMU, magnetometer, environmental sensors, BSEC (IAQ)
  - Uses higher ODRs where API allows, then oversamples/averages in software
  - Prints a once-per-second, window-averaged snapshot to Serial (115200)
  - Drives onboard RGB LED:
      * During BSEC warm-up (accuracy 0..2): blue -> cyan -> yellow
      * When accuracy == 3: 501 distinct colors (one per IAQ value 0..500)
        using an HSV sweep from green (good) to red (bad), with hysteresis to reduce flicker.
Note: 501 hues can look very smooth; if you prefer less flicker, keep averaging (iaqS.mean()) or add hysteresis.
Board:   Arduino Nicla Sense ME
  Libs:    Arduino_BHY2 (install via Library Manager)
  Serial:  115200
*/
#include "Arduino.h"
#include "Arduino_BHY2.h"
#include "Nicla_System.h"     // for nicla::begin() and nicla::leds (I2C RGB LED)
// ======= Precision knobs (tune as needed) =======
#define ODR_IMU_HZ         200   // accel/gyro/derived vectors (Hz)
#define ODR_MAG_HZ          50   // magnetometer (Hz)
#define ODR_ENV_HZ          25   // temp/hum/baro/gas (Hz)
#define PRINT_INTERVAL_MS 1000   // averaging window size and print cadence
// ======= Motion / Orientation (corrected streams) =======
SensorXYZ         acc (SENSOR_ID_ACC);       // m/s^2
SensorXYZ         gyro(SENSOR_ID_GYRO);      // deg/s
SensorXYZ         mag (SENSOR_ID_MAG);       // µT
SensorXYZ         lacc(SENSOR_ID_LACC);      // m/s^2
SensorXYZ         grav(SENSOR_ID_GRA);       // m/s^2
SensorOrientation ori (SENSOR_ID_ORI);       // deg
SensorQuaternion  rv  (SENSOR_ID_RV);        // quaternion
// ======= Environmental =======
Sensor            temp(SENSOR_ID_TEMP);      // °C
Sensor            hum (SENSOR_ID_HUM);       // %RH
Sensor            baro(SENSOR_ID_BARO);      // hPa
Sensor            gas (SENSOR_ID_GAS);       // Ohms
// ======= Air Quality via BSEC (BME688) =======
SensorBSEC        bsec(SENSOR_ID_BSEC);      // IAQ, eCO2, bVOCeq, comp. T/H/G
// ======= Activity / Gestures / Steps (optional) =======
SensorActivity    activity    (SENSOR_ID_AR);
Sensor            tilt        (SENSOR_ID_TILT_DETECTOR);
Sensor            stepCounter (SENSOR_ID_STC);
Sensor            stepDetector(SENSOR_ID_STD);
// ------------ simple accumulate/average helpers ------------
struct Stats1D {
  double   sum = 0.0;
  double   sum2 = 0.0;
  uint32_t n = 0;
  void   add(double v) { sum += v; sum2 += v*v; n++; }
  double mean()  const { return (n ? sum / n : NAN); }
  double stddev() const {
    return (n > 1 ? sqrt((sum2 / n) - sq(sum / n)) : NAN);
  }
  void   clear() { sum = sum2 = 0.0; n = 0; }
};
struct Stats3D {
  Stats1D x, y, z;
  void add(double vx, double vy, double vz) { x.add(vx); y.add(vy); z.add(vz); }
  void clear() { x.clear(); y.clear(); z.clear(); }
};
static Stats3D accS, gyroS, magS, laccS, gravS;
static Stats1D tempS, humS, baroS, gasS, iaqS, eco2S, bvocS;
static uint32_t lastPrint = 0;
// ======== RGB LED helpers: 1-point IAQ buckets (0..500) => 501 distinct RGB colors + hysteresis ========
// ---- Tuning knobs for LED behavior ----
constexpr uint16_t IAQ_MIN = 0;
constexpr uint16_t IAQ_MAX = 500;
// How much IAQ must change (points) before the LED color updates.
// Typical values: 2–5. Larger = less flicker, but slower responsiveness.
constexpr uint8_t HYSTERESIS_POINTS = 3;

// Optional color tuning
constexpr float LED_SAT = 1.0f;  // saturation (0..1)
constexpr float LED_VAL = 1.0f;  // brightness/value (0..1)
// Clamp helper
static inline uint16_t clampU16(int v, int lo, int hi) {
  if (v < lo) return lo;
  if (v > hi) return hi;
  return (uint16_t)v;
}
// HSV -> RGB (h in [0,360), s & v in [0,1])
static void hsvToRgb(float h, float s, float v, uint8_t &r, uint8_t &g, uint8_t &b) {
  float c  = v * s;
  float h6 = fmodf(h / 60.0f, 6.0f);
  float x  = c * (1.0f - fabsf(fmodf(h6, 2.0f) - 1.0f));
  float m  = v - c;
float rp=0, gp=0, bp=0;
  if      (0.0f <= h6 && h6 < 1.0f) { rp = c; gp = x; bp = 0; }
  else if (1.0f <= h6 && h6 < 2.0f) { rp = x; gp = c; bp = 0; }
  else if (2.0f <= h6 && h6 < 3.0f) { rp = 0; gp = c; bp = x; }
  else if (3.0f <= h6 && h6 < 4.0f) { rp = 0; gp = x; bp = c; }
  else if (4.0f <= h6 && h6 < 5.0f) { rp = x; gp = 0; bp = c; }
  else                              { rp = c; gp = 0; bp = x; }
r = (uint8_t)roundf((rp + m) * 255.0f);
  g = (uint8_t)roundf((gp + m) * 255.0f);
  b = (uint8_t)roundf((bp + m) * 255.0f);
}
// Convert IAQ index (0..500) to an RGB color and set it
static inline void setColorFromIdx(uint16_t idx) {
  // Hue sweep: idx=0 -> 120° (green, good), idx=500 -> 0° (red, bad)
  const float hue = 120.0f * (1.0f - (idx / 500.0f));
  uint8_t r, g, b;
  hsvToRgb(hue, LED_SAT, LED_VAL, r, g, b);
  nicla::leds.setColor(r, g, b);
}
// Map IAQ (0..500) to 1-point buckets with hysteresis to reduce flicker.
// 501 hues can look very smooth; if you prefer less flicker, keep averaging (iaqS.mean()) or add hysteresis.
static void setColorForIAQ_1step_hysteresis(uint16_t iaq_raw) {
  const uint16_t idx = clampU16(iaq_raw, IAQ_MIN, IAQ_MAX); // 0..500 (501 steps)
// Persist the last "stable" index across calls
  static int16_t stableIdx = -1; // -1 means uninitialized
// First-time initialization: set color immediately
  if (stableIdx < 0) {
    stableIdx = (int16_t)idx;
    setColorFromIdx((uint16_t)stableIdx);
    return;
  }
// Hysteresis: update only if IAQ moves outside a ±HYSTERESIS_POINTS deadband
  const int diff = (int)idx - stableIdx;
  if (diff >= (int)HYSTERESIS_POINTS || diff <= -(int)HYSTERESIS_POINTS) {
    stableIdx = (int16_t)idx;
    setColorFromIdx((uint16_t)stableIdx);
  } else {
    // Within deadband: keep last LED color
  }
}
// Update LED once per window: warm-up colors until accuracy==3, then IAQ-driven color (with hysteresis).
static void updateStatusLED() {
  static uint32_t lastLed = 0;
  if (millis() - lastLed < PRINT_INTERVAL_MS) return;
  lastLed = millis();
switch (bsec.accuracy()) {
    case 0: nicla::leds.setColor(blue);   return; // boot / not ready
    case 1: nicla::leds.setColor(cyan);   return; // early warm-up
    case 2: nicla::leds.setColor(yellow); return; // almost ready
    case 3: default: break;                       // ready -> color by IAQ
  }
float iaqMean = iaqS.mean();
  if (isnan(iaqMean)) { nicla::leds.setColor(cyan); return; }
// Round to nearest integer IAQ and color with 1-point resolution + hysteresis
  setColorForIAQ_1step_hysteresis((uint16_t)roundf(iaqMean));
}
// ======= Configure all sensors =======
void configureAll() {
  // Initialize BHY2 (standalone)
  BHY2.begin();
// --- Motion / Orientation ---
  acc.configure (ODR_IMU_HZ, 0);
  gyro.configure(ODR_IMU_HZ, 0);
  lacc.configure(ODR_IMU_HZ, 0);
  grav.configure(ODR_IMU_HZ, 0);
  ori.configure (ODR_IMU_HZ, 0);
  rv.configure  (ODR_IMU_HZ, 0);
// --- Magnetometer ---
  mag.configure(ODR_MAG_HZ, 0);
// --- Environmental ---
  temp.configure(ODR_ENV_HZ, 0);
  hum.configure (ODR_ENV_HZ, 0);
  baro.configure(ODR_ENV_HZ, 0);
  gas.configure (ODR_ENV_HZ, 0);
// --- BSEC (BME688) ---
  bsec.begin(); // profile handled internally; accuracy will rise to 3 over time
// --- Activity / steps (optional) ---
  activity.configure    (5, 0);
  tilt.configure        (5, 0);
  stepCounter.configure (1, 0);
  stepDetector.configure(5, 0);
}
void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 3000) {}
  Serial.println(F("\nNicla Sense ME – High Precision Readout + RGB IAQ (1-step + hysteresis)"));

// Initialize board helpers and LED
  nicla::begin();
  nicla::leds.begin();
  nicla::leds.setColor(blue);   // boot indicator
configureAll();
}
void loop() {
  // Always service the sensor hub
  BHY2.update();
// Accumulate latest samples (oversampling) ---------------
  // Motion
  accS.add (acc.x(),  acc.y(),  acc.z());
  gyroS.add(gyro.x(), gyro.y(), gyro.z());
  magS.add (mag.x(),  mag.y(),  mag.z());
  laccS.add(lacc.x(), lacc.y(), lacc.z());
  gravS.add(grav.x(), grav.y(), grav.z());
// Environmental
  tempS.add(temp.value());
  humS.add (hum.value());
  baroS.add(baro.value());
  gasS.add (gas.value());
// BSEC
  iaqS.add (bsec.iaq());
  eco2S.add(bsec.co2_eq());
  bvocS.add(bsec.b_voc_eq());
// Once per PRINT_INTERVAL_MS: print averaged snapshot ----
  const uint32_t now = millis();
  if (now - lastPrint >= PRINT_INTERVAL_MS) {
    lastPrint = now;
Serial.println();
    Serial.println(F("=================================================="));
    Serial.println(F("Averaged high-precision snapshot"));
// --- Motion / Orientation ---
    Serial.println(F("[Motion - means ± stddev]"));
    Serial.print(F("  Acc (m/s^2):     "));
    Serial.print(accS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(accS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(accS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(accS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(accS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(accS.z.stddev(), 6);
Serial.print(F("  Gyro (deg/s):    "));
    Serial.print(gyroS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(gyroS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gyroS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(gyroS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gyroS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(gyroS.z.stddev(), 6);
Serial.print(F("  Mag (uT):        "));
    Serial.print(magS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(magS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(magS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(magS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(magS.z.stddev(), 6);
Serial.print(F("  LinAcc (m/s^2):  "));
    Serial.print(laccS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(laccS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(laccS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(laccS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(laccS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(laccS.z.stddev(), 6);
Serial.print(F("  Gravity (m/s^2): "));
    Serial.print(gravS.x.mean(), 6); Serial.print(F(" ± ")); Serial.print(gravS.x.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gravS.y.mean(), 6); Serial.print(F(" ± ")); Serial.print(gravS.y.stddev(), 6);
    Serial.print(F(", ")); Serial.print(gravS.z.mean(), 6); Serial.print(F(" ± ")); Serial.println(gravS.z.stddev(), 6);
// Orientation & rotation (live, not averaged — quaternions require special averaging)
    Serial.println(F("  Orientation (deg):"));
    Serial.print (F("    pitch="));  Serial.print(ori.pitch(), 6);
    Serial.print (F(", roll="));     Serial.print(ori.roll(), 6);
    Serial.print (F(", heading="));  Serial.println(ori.heading(), 6);

Serial.print (F("  Rotation Vector (quat): "));
    Serial.print(F("w=")); Serial.print(rv.w(), 6);
    Serial.print(F(", x=")); Serial.print(rv.x(), 6);
    Serial.print(F(", y=")); Serial.print(rv.y(), 6);
    Serial.print(F(", z=")); Serial.println(rv.z(), 6);
// --- Environmental ---
    Serial.println(F("[Environmental - means ± stddev]"));
    Serial.print(F("  Temperature (C): ")); Serial.print(tempS.mean(), 6); Serial.print(F(" ± ")); Serial.println(tempS.stddev(), 6);
    Serial.print(F("  Humidity (%RH):  ")); Serial.print(humS.mean(), 6);  Serial.print(F(" ± ")); Serial.println(humS.stddev(), 6);
    Serial.print(F("  Pressure (hPa):  ")); Serial.print(baroS.mean(), 6); Serial.print(F(" ± ")); Serial.println(baroS.stddev(), 6);
    Serial.print(F("  Gas (Ohms):      ")); Serial.print(gasS.mean(), 2);  Serial.print(F(" ± ")); Serial.println(gasS.stddev(), 2);
// --- BSEC (IAQ etc.) ---
    Serial.println(F("[Air Quality - BSEC]"));
    Serial.print (F("  IAQ: "));         Serial.print(iaqS.mean(), 2);
    Serial.print (F(" (acc "));           Serial.print(bsec.accuracy()); Serial.println(F(" of 3)"));
    Serial.print (F("  eCO2 (ppm): "));  Serial.println(eco2S.mean(), 1);
    Serial.print (F("  bVOCeq (ppm): "));Serial.println(bvocS.mean(), 3);
    Serial.print (F("  Comp T/H/G: "));
    Serial.print (bsec.comp_t(), 2); Serial.print(F(" C, "));
    Serial.print (bsec.comp_h(), 2); Serial.print(F(" %RH, "));
    Serial.print (bsec.comp_g());   Serial.println(F(" Ohms"));
// Optional status
    Serial.print(F("Samples this window ~ IMU: "));
    Serial.print(accS.x.n); Serial.print(F(", ENV: ")); Serial.println(tempS.n);
// Update LED for this window
    updateStatusLED();
// Clear accumulators for next window
    accS.clear(); gyroS.clear(); magS.clear(); laccS.clear(); gravS.clear();
    tempS.clear(); humS.clear(); baroS.clear(); gasS.clear();
    iaqS.clear();  eco2S.clear(); bvocS.clear();
  }
}

From <https://m365.cloud.microsoft/chat?fromcode=cmc&redirectid=34F168E70DF74F75AB99856FC952306F&auth=2> 



