/*
 * T-Display S3 Long (AXS15231B, 180x640) + TMP117
 * Visually enhanced UI with:
 *   - Big temperature readout
 *   - Warm-up and averaging progress bars
 *   - Spec panel card showing: Conversion=1s, Warm-up=30–60s, Averaging=30–60s
 *   - Live 1-minute average and sample counter
 *
 * Wiring (verify your board’s I2C pins; many S3 Long builds use SDA=15, SCL=10):
 *   3V3  → TMP117 VCC
 *   GND  → TMP117 GND
 *   GPIO15 (SDA) → TMP117 SDA
 *   GPIO10 (SCL) → TMP117 SCL
 *
 * Display note:
 *   We render to a 640x180 TFT_eSPI sprite, then push with lcd_PushColors_rotated_90()
 *   using LilyGO’s AXS15231B driver.
 */

#include "AXS15231B.h"     // LilyGO driver (from repo /lib)
#include <Arduino.h>
#include <TFT_eSPI.h>      // Sprite engine only
#include <Wire.h>

// ============================ USER CONFIG ============================
// I2C pins (adjust if needed)
#define I2C_SDA_PIN 15
#define I2C_SCL_PIN 10

// TMP117 address
#define TMP117_ADDR      0x48
#define REG_TEMP_RESULT  0x00
#define REG_CONFIG       0x01
#define REG_DEVICE_ID    0x0F

// Operating profile (recommended for stability)
static const uint32_t CONV_INTERVAL_MS = 1000;   // 1 s conversion (matching device)
static const uint32_t WARMUP_MS        = 30000;  // 30 s warm-up (set 60000 for 60 s)
static const uint16_t AVG_COUNT        = 60;     // 60 samples → 1-minute average

// Theme
#define COL_BG        0x0000   // Black
#define COL_PANEL     0x0842   // Very dark grey-blue
#define COL_FRAME     0x3186   // Grey outline
#define COL_TEXT      0xFFFF   // White
#define COL_MUTED     0xAD55   // Light grey
#define COL_ACCENT    0xFDA0   // Orange
#define COL_ACCENT2   0x07FF   // Cyan
#define COL_GOOD      0x07E0   // Green
#define COL_WARN      0xFFE0   // Yellow
#define COL_BAD       0xF800   // Red

// Fonts & layout
static const int  TITLE_Y       = 8;
static const int  TEMP_Y        = 86;   // center line for big readout
static const int  AVG_Y         = 146;
static const int  CARD_X        = 10;
static const int  CARD_Y        = 32;
static const int  CARD_W        = 210;
static const int  CARD_H        = 116;
static const int  PROG_W        = 380;
static const int  PROG_H        = 12;
static const int  PROG_X        = 240;
static const int  PROG_Y_TOP    = 46;   // warm-up progress top
static const int  PROG_Y_BOT    = 66;   // averaging progress top

// ====================================================================

// Display objects
TFT_eSPI tft(180, 640);
TFT_eSprite sprite(&tft);

// ---------- TMP117 helpers ----------
static bool writeReg16(uint8_t reg, uint16_t value) {
  Wire.beginTransmission(TMP117_ADDR);
  Wire.write(reg);
  Wire.write(value >> 8);          // MSB
  Wire.write(value & 0xFF);        // LSB
  return (Wire.endTransmission() == 0);
}

static bool readReg16(uint8_t reg, uint16_t &value) {
  Wire.beginTransmission(TMP117_ADDR);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) return false;  // repeated START
  if (Wire.requestFrom((int)TMP117_ADDR, 2) != 2) return false;
  uint8_t msb = Wire.read();
  uint8_t lsb = Wire.read();
  value = ((uint16_t)msb << 8) | lsb;
  return true;
}

// TMP117 CONFIG: continuous, 1 s, 8× internal averaging
static uint16_t makeConfigCont_1s_Avg8() {
  const uint16_t AVG_8X    = (1u << 9);  // [10:9] = 01b
  const uint16_t CONV_1S   = (4u << 5);  // [7:5]  = 100b
  const uint16_t MODE_CONT = (0u << 4);  // [4]    = 0 → continuous
  return (AVG_8X | CONV_1S | MODE_CONT);
}

static inline float rawToC(uint16_t raw) {
  int16_t s = (int16_t)raw;      // two's complement
  return (float)s * 0.0078125f;  // 1/128 °C per LSB
}

// ---------- UI helpers ----------
void drawRoundedRect(int x, int y, int w, int h, uint16_t colOutline, uint16_t colFill, int r = 6) {
  sprite.fillRoundRect(x, y, w, h, r, colFill);
  sprite.drawRoundRect(x, y, w, h, r, colOutline);
}

void drawProgressBar(int x, int y, int w, int h, float frac, uint16_t colBar, uint16_t colBg, uint16_t colOutline) {
  if (frac < 0) frac = 0; if (frac > 1) frac = 1;
  sprite.drawRect(x - 1, y - 1, w + 2, h + 2, colOutline);
  sprite.fillRect(x, y, w, h, colBg);
  int fillw = (int)(w * frac + 0.5f);
  if (fillw > 0) sprite.fillRect(x, y, fillw, h, colBar);
}

void drawSpecCard() {
  // Left spec card
  drawRoundedRect(CARD_X, CARD_Y, CARD_W, CARD_H, COL_FRAME, COL_PANEL, 8);

  sprite.setTextColor(COL_MUTED, COL_PANEL);
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextSize(1);
  sprite.drawString("Operating Profile", CARD_X + 10, CARD_Y + 8);

  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.setTextSize(1);
  int ty = CARD_Y + 28;
  sprite.drawString("Conversion Time:", CARD_X + 10, ty);            sprite.setTextColor(COL_ACCENT, COL_PANEL); sprite.drawString("1 s", CARD_X + 140, ty); ty += 16;
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.drawString("Warm-up Duration:", CARD_X + 10, ty);           sprite.setTextColor(COL_ACCENT, COL_PANEL); sprite.drawString("30–60 s", CARD_X + 140, ty); ty += 16;
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.drawString("Averaging Window:", CARD_X + 10, ty);           sprite.setTextColor(COL_ACCENT, COL_PANEL); sprite.drawString("30–60 s", CARD_X + 140, ty); ty += 16;

  // Footnote
  sprite.setTextColor(COL_MUTED, COL_PANEL);
  sprite.setTextSize(1);
  sprite.drawString("TMP117 @ 1 Hz, 8× internal avg", CARD_X + 10, CARD_Y + CARD_H - 16);
}

void drawHeader() {
  sprite.setTextDatum(TC_DATUM);
  sprite.setTextColor(COL_TEXT, COL_BG);
  sprite.setTextSize(2);
  sprite.drawString("TMP117 — T‑Display S3 Long", 320, TITLE_Y);
}

void drawBigTemperature(float tC) {
  // Big readout box (right side)
  const int boxX = 240, boxY = 84, boxW = 390, boxH = 64;
  drawRoundedRect(boxX, boxY, boxW, boxH, COL_FRAME, 0x0010 /*very dark blue*/, 8);

  sprite.setTextDatum(MC_DATUM);
  sprite.setTextColor(COL_ACCENT2, 0x0010);
  sprite.setTextSize(7);

  char buf[40];
  if (!isnan(tC)) snprintf(buf, sizeof(buf), "%.4f °C", tC);
  else            snprintf(buf, sizeof(buf), "--.-- °C");
  sprite.drawString(buf, boxX + boxW/2, TEMP_Y);
}

void drawAvgAndCounters(float avgC, uint16_t sampleIdx) {
  // Average label
  sprite.setTextDatum(TC_DATUM);
  sprite.setTextColor(COL_MUTED, COL_BG);
  sprite.setTextSize(1);
  sprite.drawString("1‑min average", 435, AVG_Y - 18);

  // Average value
  sprite.setTextDatum(TC_DATUM);
  sprite.setTextColor(COL_WARN, COL_BG);
  sprite.setTextSize(2);
  char buf[40];
  if (!isnan(avgC)) snprintf(buf, sizeof(buf), "%.4f °C", avgC);
  else              snprintf(buf, sizeof(buf), "--.-- °C");
  sprite.drawString(buf, 435, AVG_Y + 2);

  // Sample counter
  sprite.setTextColor(COL_MUTED, COL_BG);
  sprite.setTextSize(1);
  char cbuf[32];
  snprintf(cbuf, sizeof(cbuf), "Samples: %u / %u", (unsigned)sampleIdx, (unsigned)AVG_COUNT);
  sprite.drawString(cbuf, 600, AVG_Y + 22);
}

void drawWarmupAndAveragingBars(uint32_t warmupElapsedMs, uint16_t samplesTaken) {
  // Warm-up
  float fWarm = min(1.0f, (float)warmupElapsedMs / (float)WARMUP_MS);
  sprite.setTextDatum(TL_DATUM);
  sprite.setTextColor(COL_TEXT, COL_BG);
  sprite.setTextSize(1);
  sprite.drawString("Warm‑up", PROG_X, PROG_Y_TOP - 12);
  drawProgressBar(PROG_X, PROG_Y_TOP, PROG_W, PROG_H, fWarm, COL_GOOD, 0x0841, COL_FRAME);

  // Averaging
  float fAvg = min(1.0f, (float)samplesTaken / (float)AVG_COUNT);
  sprite.setTextColor(COL_TEXT, COL_BG);
  sprite.drawString("Averaging", PROG_X, PROG_Y_BOT - 12);
  drawProgressBar(PROG_X, PROG_Y_BOT, PROG_W, PROG_H, fAvg, COL_WARN, 0x0841, COL_FRAME);
}

void drawFrame(const char* status, float tC, float avgC,
               uint32_t warmupElapsedMs, uint16_t samplesTaken) {
  sprite.fillSprite(COL_BG);
  drawHeader();
  drawSpecCard();
  drawWarmupAndAveragingBars(warmupElapsedMs, samplesTaken);
  drawBigTemperature(tC);
  drawAvgAndCounters(avgC, samplesTaken);

  // Status ribbon
  const int rx = 10, ry = 154, rw = 210, rh = 16;
  drawRoundedRect(rx, ry, rw, rh, COL_FRAME, COL_PANEL, 6);
  sprite.setTextDatum(MC_DATUM);
  sprite.setTextColor(COL_TEXT, COL_PANEL);
  sprite.setTextSize(1);
  sprite.drawString(status, rx + rw/2, ry + rh/2);

  // Push full frame (rotate to bar orientation)
  lcd_PushColors_rotated_90(0, 0, 640, 180, (uint16_t*)sprite.getPointer());
}

// ============================ SETUP / LOOP ============================

void setup() {
  Serial.begin(115200);

  // Backlight off during init
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, LOW);

  // Init display controller
  axs15231_init();

  // Create sprite (16-bit RGB565)
  sprite.createSprite(640, 180);
  sprite.setSwapBytes(1);

  // Clear panel once
  lcd_fill(0, 0, 180, 640, 0x0000);

  // Backlight on
  digitalWrite(TFT_BL, HIGH);

  // I2C init @400kHz on chosen pins
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  Wire.setClock(400000);

  // Confirm TMP117
  uint16_t id = 0;
  const char* status = "TMP117 OK";
  if (!readReg16(REG_DEVICE_ID, id) || id != 0x0117) {
    status = "TMP117 ID mismatch";
  }

  // Configure TMP117: continuous, 1 s, 8× avg
  uint16_t cfg = makeConfigCont_1s_Avg8();
  if (!writeReg16(REG_CONFIG, cfg)) {
    status = "Config write failed";
  }

  // Warm-up screen
  uint32_t start = millis();
  while (millis() - start < WARMUP_MS) {
    uint32_t elapsed = millis() - start;
    drawFrame("Warming up…", NAN, NAN, elapsed, 0);
    delay(120);
  }
}

void loop() {
  // 60 readings @1s → 1-minute average
  double sum = 0.0;
  float lastT = NAN;
  uint32_t warmupDone = WARMUP_MS; // for UI bars

  for (uint16_t i = 0; i < AVG_COUNT; i++) {
    delay(CONV_INTERVAL_MS);

    uint16_t raw;
    if (!readReg16(REG_TEMP_RESULT, raw)) {
      drawFrame("I2C read error", lastT, NAN, warmupDone, i);
      continue;
    }

    float tC = rawToC(raw);
    lastT = tC;
    sum += tC;

    float avgNow = (i > 0) ? (float)(sum / (i + 1)) : NAN;
    drawFrame("Averaging…", tC, avgNow, warmupDone, i + 1);
  }

  float avg1m = (float)(sum / AVG_COUNT);
  drawFrame("1‑minute avg ready", NAN, avg1m, warmupDone, AVG_COUNT);
  delay(1000);
}
